import{_ as s,c as e,a as n,o as l}from"./app-yHXsKH7I.js";const a="/screenshot/backend/image-20260117170137026.png",t="/screenshot/backend/image-20260117171642309.png",d="/screenshot/backend/image-20260117192823578.png",r="/screenshot/backend/image-20260116134036265.png",h="/screenshot/backend/image-20260116134013876.png",o="/screenshot/backend/image-20260116134539535.png",p={};function c(g,i){return l(),e("div",null,[...i[0]||(i[0]=[n('<p><a href="/pdfs/golang/DB.pdf">本页PDF</a></p><h2 id="db的查漏补缺" tabindex="-1"><a class="header-anchor" href="#db的查漏补缺"><span>DB的查漏补缺</span></a></h2><h3 id="mysql体系结构" tabindex="-1"><a class="header-anchor" href="#mysql体系结构"><span>MySQL体系结构</span></a></h3><p><strong>MySQL服务端</strong></p><ul><li><strong>连接层</strong>：负责权限校验，连接处理等</li><li><strong>服务层</strong>：负责SQL分析和优化，SQL接口等</li><li><strong>引擎层</strong>：可插拔的存储引擎层，不同的<strong>存储引擎</strong>有不同的功能，索引是在这个层实现的</li><li><strong>存储层</strong>：将数据存储在磁盘中，并完成与存储引擎的交互</li></ul><figure><img src="'+a+`" alt="image-20260117170137026" tabindex="0" loading="lazy"><figcaption>image-20260117170137026</figcaption></figure><h3 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb"><span>InnoDB</span></a></h3><p>MySQL默认使用的<strong>存储引擎</strong>，它提供</p><ul><li><strong>事务</strong></li><li><strong>行级锁</strong></li><li><strong>外键</strong></li><li>索引</li><li>高并发读写</li></ul><p>等功能</p><p><strong>特点</strong></p><ul><li><p>存储引擎是基于表的，<strong>不同的表可以有不同的存储引擎</strong></p></li><li><p>InnoDB引擎的每张表都对应一个表空间文件<code>.ibd</code>，存储表<strong>结构、数据、索引</strong></p></li></ul><p><strong>常用语法</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 查看存储引擎</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show engines;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 建表时指定存储引擎</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> tb_name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(...) engine </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Innodb;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="逻辑存储结构" tabindex="-1"><a class="header-anchor" href="#逻辑存储结构"><span>逻辑存储结构</span></a></h4><p>主要包括</p><ul><li><code>TableSpace</code>：表空间，<code>.idb</code>文件，用于存储记录、索引等</li><li><code>Segment</code>：段，分为数据段、索引段、回滚段 <ul><li>InnoDB是索引组织表，<strong>数据段</strong>就是B+树叶子节点，<strong>索引段</strong>就是B+树非叶子节点</li><li>段用来管理多个区</li></ul></li><li><code>Extent</code>：区，大小是1M，一个区默认包含64个连续的页 <ul><li>InnoDB存储引擎每次从磁盘申请4-5个区，<strong>保证申请到的页是连续的</strong></li></ul></li><li><code>Page</code>：页，<strong>磁盘操作的最小单元</strong>，大小是16KB</li><li><code>Row</code>：行 <ul><li><code>Trx_id</code>：最后一次操作事务的id</li><li><code>Roll_pointer</code>：指针，指向<code>undo log</code>里的一条<code>undo</code>记录</li></ul></li></ul><figure><img src="`+t+'" alt="image-20260117171642309" tabindex="0" loading="lazy"><figcaption>image-20260117171642309</figcaption></figure><h4 id="常见存储引擎区别" tabindex="-1"><a class="header-anchor" href="#常见存储引擎区别"><span>常见存储引擎区别</span></a></h4><p><strong>MyISAM</strong></p><ul><li>不支持事务、外键</li><li>不支持行锁</li><li>访问速度快</li><li><code>.sdi</code>存储表结构，<code>.MYD</code>存储数据，<code>.MYI</code>存储索引</li></ul><p><strong>Memory</strong></p><ul><li>数据存放在内存中，适合做临时表</li><li>访问速度快</li><li>使用hash索引</li><li>只有<code>.sdi</code>文件，存放表结构</li></ul><table><thead><tr><th style="text-align:center;">特点</th><th style="text-align:center;">InnoDB</th><th style="text-align:center;">MyISAM</th><th style="text-align:center;">Memory</th></tr></thead><tbody><tr><td style="text-align:center;">事务</td><td style="text-align:center;">支持</td><td style="text-align:center;">不支持</td><td style="text-align:center;">不支持</td></tr><tr><td style="text-align:center;">锁</td><td style="text-align:center;">行锁</td><td style="text-align:center;">表锁</td><td style="text-align:center;">表锁</td></tr><tr><td style="text-align:center;">外键</td><td style="text-align:center;">支持</td><td style="text-align:center;">不支持</td><td style="text-align:center;">不支持</td></tr></tbody></table><h4 id="架构" tabindex="-1"><a class="header-anchor" href="#架构"><span>架构</span></a></h4><p>左侧为<strong>内存架构</strong>，右侧为<strong>磁盘架构</strong></p><figure><img src="'+d+'" alt="image-20260117192823578" tabindex="0" loading="lazy"><figcaption>image-20260117192823578</figcaption></figure><h5 id="内存架构" tabindex="-1"><a class="header-anchor" href="#内存架构"><span>内存架构</span></a></h5><p><strong><code>Buffer Pool</code></strong>：缓冲池，是<strong>主内存的一个区域</strong>，可以缓存<strong>磁盘上的真实数据</strong></p><ul><li>执行增删改查操作时，<strong>先操作缓冲池的数据</strong>（缓冲池无数据，则从磁盘加载并缓存）</li><li>会以<strong>一定频率把缓冲池的数据刷新到磁盘</strong>，减少磁盘IO，加快处理速度</li><li><strong>以页为单位，采用链表的数据结构管理页</strong>，有三种类型的页 <ul><li><code>free page</code>：空闲页，未被使用</li><li><code>clean page</code>：被使用的页，数据未被修改</li><li><code>dirty page</code>：脏页，被使用的页，数据被修改过，数据与磁盘的数据产生不一致</li></ul></li></ul><p><strong><code>Change Buffer</code></strong>：更改缓冲区</p><ul><li><p><strong>针对非聚簇索引</strong>执行增删改语句且这些数据没有在<code>Buffer Pool</code>的时候，会先把<strong>数据变更</strong>缓存在<code>Change Buffer</code>中</p></li><li><p>未来数据被读取时，再将数据合并恢复到<code>Buffer Pool</code>中，再将合并后的数据刷新到磁盘中</p></li><li><p><strong>存在的意义</strong>：增删改数据时，在修改聚簇索引的同时还要修改非聚簇索引，但是非聚簇索引的目标页可能不在<code>Buffer Pool</code>里，如果每变更一下数据就去磁盘找非聚簇索引的目标页进行更改，就会造成大量的磁盘IO。<code>Change Buffer</code>使用<strong>延迟合并换取更少的磁盘IO</strong>，提升效率</p></li></ul><p><strong><code>Log Buffer</code></strong>：日志缓冲区，用来保存要写入到磁盘中的日志数据</p><ul><li>主要是<code>redo log buffer</code></li><li>默认大小为16MB，数据会定期刷新到磁盘中</li><li>参数： <ul><li><code>innodb_log_buffer_size</code>：缓冲区大小</li><li><code>innodb_flush_log_at_trx_commit</code>：日志刷新到磁盘时机 <ul><li>0：每秒将日志写入并刷新到磁盘一次</li><li>1：日志在每次事务提交时写入并刷新到磁盘</li><li>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</li></ul></li></ul></li></ul><p><strong><code>Adaptive Hash Index</code></strong>：自适应哈希索引，用于优化对<code>Buffer Pool</code>数据的查询</p><ul><li>如果MySQL观察到<code>hash</code>索引可以提升速度，则建立<code>hash</code>索引</li><li>无需人工干预</li><li>适用于等值查询</li><li>参数：<code>adaptive_hash_index</code></li></ul><h5 id="磁盘架构" tabindex="-1"><a class="header-anchor" href="#磁盘架构"><span>磁盘架构</span></a></h5><p><strong><code>System Tablespace</code></strong>：系统表空间，存储更改缓冲区的数据，<strong>它可能包含表和索引数据</strong></p><ul><li><code>innodb_data_file_path</code>：存储路径</li></ul><p><strong><code>File-Per-Table-Tablespaces</code></strong>：每个表文件的表空间，存放单个<code>InnoDB</code>表的数据和索引，存储在文件系统的单个数据文件</p><ul><li><code>innodb_file_per_table</code>：是否开启</li></ul><p><strong><code>General Tablespaces</code></strong>：通用表空间，需要自己创建，可以指定特定的表存在这个表空间</p><p><strong><code>Undo Tablespaces</code></strong>：撤销表空间，用于存储<code>undo log</code>日志</p><p><strong><code>Temporary Tablespaces</code></strong>：临时表空间，用于存储用户创建的临时表</p><p><strong><code>Doublewrite Buffer Files</code></strong>：双写缓冲区，InnoDB将数据页从<code>Buffer Pool</code>刷到磁盘前，会先把数据写入到双写缓冲区中</p><ul><li>为<code>.dblwr</code>文件</li></ul><p><strong><code>Redo Log</code></strong>：重做日志，实现<strong>事务的持久性</strong></p><ul><li>由重做日志缓冲区（在内存中）和重做日志文件（在磁盘中）组成</li><li>事务提交之后会把所有修改信息存到该日志中，可以用于数据恢复</li></ul><h5 id="后台线程" tabindex="-1"><a class="header-anchor" href="#后台线程"><span>后台线程</span></a></h5><p><strong>作用</strong>：把缓冲池的数据刷新到磁盘中</p><p>包括</p><ul><li><code>Master Thread</code>：核心后台线程，负责调度其它线程，将缓冲池数据异步刷新到磁盘，脏页刷新，合并插入缓存，undo页的回收</li><li><code>IO Thread</code>：Innodb使用异步非阻塞IO处理IO请求，<code>IO Thread</code>负责这些IO请求的回调 <ul><li><code>Read Thread</code>：负责读操作</li><li><code>Write Thread</code>：负责写操作</li><li><code>Log Thread</code>：负责将日志缓冲区刷新到磁盘</li><li><code>Insert Buffer Thread</code>：负责将写缓冲区内容刷新到磁盘</li></ul></li><li><code>Purge Thread</code>：用于回收事务已经提交的<code>undo log</code></li><li><code>Page Cleaner Thread</code>：协助<code>Master Thread</code>把刷新脏页到磁盘的线程</li></ul><h4 id="事务原理" tabindex="-1"><a class="header-anchor" href="#事务原理"><span>事务原理</span></a></h4><p><code>redo log</code>和<code>undo log</code>保证事务的<strong>原子性、一致性、持久性</strong></p><ul><li><code>redo log</code>：重做日志，保证事务的<strong>持久性</strong>，记录<strong>数据页的物理修改</strong><ul><li>改<code>buffer pool</code>的页，然后把数据变更的的情况写入<code>redo log buffer</code>，再按一定策略<strong>顺序写入</strong>磁盘的<code>redo log files</code></li><li>可以避免因宕机导致内存的数据丢失而无法保证数据持久性</li></ul></li><li><code>undo log</code>：回滚日志，保证事务的<strong>原子性</strong><ul><li><strong>作用</strong>：提供回滚和MVCC</li><li>是逻辑日志，描述的是如何恢复一行到旧状态</li><li>进行<code>insert</code>时，产生的<code>undo log</code>日志在事务被提交后<strong>可被立刻删除</strong></li><li>进行<code>update</code>、<code>delete</code>的时候，产生的<code>undo log</code>日志在回滚时需要，在快照读时也需要，<strong>不会被立刻删除</strong></li></ul></li><li><code>redo log</code>和<code>undo log</code>保证事务的<strong>一致性</strong></li></ul><p>锁和MVCC保证事务的<strong>隔离性</strong></p><h4 id="mvcc" tabindex="-1"><a class="header-anchor" href="#mvcc"><span>MVCC</span></a></h4><p><strong>多版本并发控制</strong>：Multi-Version Concurrency Control，维护一个数据的多个版本，使读写操作没有冲突</p><ul><li>具体实现依赖于数据库记录中的<strong>三个隐式字段、<code>undo log</code>版本链、<code>readView</code></strong></li><li>隐式字段：<code>DB_TRX_ID</code>、<code>DB_ROLL_PTR</code>、<code>DB_ROW_ID</code><ul><li><code>DB_TRX_ID</code>：最近修改的事务ID</li><li><code>DB_ROLL_PTR</code>：回滚指针，指向上一个版本</li><li><code>DB_ROW_ID</code>：隐式主键，表结构无主键，就会生成该字段</li></ul></li></ul><p><strong>基本概念</strong></p><ul><li>当前读：读取的是记录的最新版本，读取时要保证其它并发事务不能修改读取记录（否则造成不可重复读），会对<strong>读取的事务进行加锁</strong></li><li>快照读：简单的<code>select</code>，不加锁，读取的是记录数据的可见版本，可能是历史数据</li></ul><p><strong>不同隔离级别的区别</strong></p><ul><li>读已提交：每次查询都生成一个快照读</li><li>可重复读：开启事务后第一个<code>select</code>语句才是快照读的地方</li><li>串行化：快照读退化成当前读</li></ul><p><strong>实现原理</strong></p><ul><li><strong><code>undo log</code>版本链</strong>：不同事务或相同事务对同一条记录进行修改，会导致该记录的<code>undolog</code>生成一条记录版本链表，链表头部是最新的旧纪录，尾部是最老的旧纪录</li><li><strong><code>ReadView</code></strong>：读视图，是<strong>快照读SQL执行</strong>时MVCC提取数据的依据，记录并维护系统当前<strong>活跃的未提交的事务ID</strong>、 <ul><li>包含四个<strong>核心字段</strong><ul><li><code>m_ids</code>：创建快照那一刻，活跃的未提交的事务ID集合</li><li><code>min_trx_id</code>：<code>m_ids</code> 里的最小值</li><li><code>max_trx_id</code>：预分配事务ID，<code>m_ids</code> 里的最大事务ID + 1</li><li><code>creator_trx_id</code>：<code>ReadView</code>创建者的事务ID</li></ul></li><li><strong>版本链数据访问规则</strong>，<code>trx_id</code>代表某个行版本的创建/最后修改事务ID <ul><li><code>trx_id == creator_trx_id</code>：可以访问该版本，说明数据是当前这个事务更改的</li><li><code>trx_id &lt; min_trx_id</code>：可以访问该版本，说明数据已经提交</li><li><code>trx_id &gt; max_trx_id</code>：不可以访问该版本，当前事务是在<code>ReadView</code>生成之后开启</li><li><code>min_trx_id &lt;= trx_id &lt;= max_trx_id</code><ul><li><code>trx_id</code> 在 <code>m_ids</code> 里，不可访问该版本，<code>trx_id</code>还未提交</li><li><code>trx_id</code> 不在 <code>m_ids</code> 里，可访问该版本，<code>trx_id</code>在快照创建前已经提交</li></ul></li></ul></li><li><strong>RC（读已提交）</strong>：每次执行快照读都会生成<code>ReadView</code></li><li><strong>RR（可重复读）</strong>：仅在事务中第一次执行快照读生成<code>ReadView</code>，后续复用该<code>ReadView</code></li></ul></li></ul><h3 id="索引" tabindex="-1"><a class="header-anchor" href="#索引"><span>索引</span></a></h3><p>帮助MySQL高效获取数据的<strong>有序数据结构</strong>，使用<code>.MYI</code>文件<strong>存放索引</strong></p><p><strong>优缺点</strong></p><ul><li><strong>优点</strong>：提高查询效率，提高排序效率</li><li><strong>缺点</strong>：占用磁盘空间，降低数据的增删改效率</li></ul><p><strong>索引结构</strong></p><p>MySQL的索引是在<strong>存储引擎层</strong>实现的，不同的存储引擎有不同的索引结构，如：</p><ul><li><strong>B+Tree索引</strong>：最常见索引类型</li><li><strong>Hash索引</strong>：使用哈希表实现，不支持范围查询</li><li><strong>R-tree索引（空间索引）</strong>：用于地理空间数据类型</li><li><strong>Full-Text（全文索引）</strong>：建立倒排索引，常用于elasticsearch</li></ul><h4 id="b树与b-树" tabindex="-1"><a class="header-anchor" href="#b树与b-树"><span>B树与B+树</span></a></h4><p>B-Tree：<strong>多路</strong>平衡查找树</p><ul><li>每一个节点可以存储<code>n</code>个key，那么就会有5个指针指向子节点</li><li><strong>核心</strong>：中间元素向上分裂</li><li>一个节点是一页，16KB</li><li>叶子节点和非叶子节点都会存储数据，导致一页中存储的键值减少，指针也减少，导致树的高度增加</li></ul><figure><img src="'+r+'" alt="image-20260116134036265" tabindex="0" loading="lazy"><figcaption>image-20260116134036265</figcaption></figure><p>B+Tree</p><ul><li><p>非叶子节点主要起到索引的作用</p></li><li><p>所有的数据都会出现在叶子节点，叶子节点形成一个单向链表</p></li></ul><figure><img src="'+h+'" alt="image-20260116134013876" tabindex="0" loading="lazy"><figcaption>image-20260116134013876</figcaption></figure><p>MySQL中在原B+树基础上增加一个<strong>指向相邻叶子节点的链表指针</strong></p><figure><img src="'+o+`" alt="image-20260116134539535" tabindex="0" loading="lazy"><figcaption>image-20260116134539535</figcaption></figure><h4 id="索引分类" tabindex="-1"><a class="header-anchor" href="#索引分类"><span>索引分类</span></a></h4><p>有四种分类：</p><ul><li><strong>主键索引</strong>：只能有一个，关键字为<code>PRIMARY</code></li><li><strong>唯一索引</strong>：可以有多个，关键字为<code>UNIQUE</code></li><li><strong>常规索引</strong>：可以有多个</li><li><strong>全文索引</strong>：可以有多个，关键字为<code>FULLTEXT</code></li></ul><h4 id="聚簇索引与非聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引与非聚簇索引"><span>聚簇索引与非聚簇索引</span></a></h4><p>也叫做<strong>聚焦索引</strong>和<strong>二级索引</strong></p><ul><li><strong>聚簇索引</strong>：数据存储与索引放在一起，索引结构的叶子节点存放了行数据，<strong>必须有且只有一个</strong><ul><li>本质上就是表本身，而主键就是聚簇索引键</li></ul></li><li><strong>非聚簇索引</strong>：数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 <ul><li>额外的独立B+树，索引键是<strong>手动指定</strong>的</li></ul></li></ul><p><strong>聚簇索引选取规则</strong></p><ul><li>如果存在主键，<strong>主键索引</strong>就是聚簇索引</li><li>如果不存在主键，则使用<strong>第一个唯一索引</strong>作为聚簇索引</li><li>如果表没有主键也没有合适的唯一索引，InnoDB会自动生成一个<code>rowid</code>作为<strong>隐藏的聚簇索引</strong></li></ul><p><strong>回表查询</strong>：先走二级查询（非聚簇索引查询）拿到主键值，再根据主键值到聚簇索引中拿到数据的所有信息</p><h4 id="索引语法" tabindex="-1"><a class="header-anchor" href="#索引语法"><span>索引语法</span></a></h4><p><strong>创建索引</strong></p><ul><li>单列索引：一个索引关联一个字段</li><li>联合索引：一个索引关联多个字段，用多个字段来创建B+树</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- unique|fulltext: 确定索引类型为unique或者fulltext</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- index_name: 索引名称</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- table_name: 表名</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- index_col_name: 字段名</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [unique|fulltext]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name (index_col_name,...);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查看索引</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">index</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>删除索引</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">drop</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="联合索引的最左匹配原则" tabindex="-1"><a class="header-anchor" href="#联合索引的最左匹配原则"><span>联合索引的最左匹配原则</span></a></h4><p><strong>联合索引</strong>：一个索引关联了多个字段</p><p><strong>最左匹配法则</strong>：查询从索引的最左列开始，并且<strong>不跳过</strong>索引中的列，如果跳过某一列，后面的<strong>字段索引失效</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 联合索引: (name,age,school)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;wjh&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> school </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;ecust&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 不失效</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;wjh&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> school </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;ecust&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 只用了name列的索引，school列索引失效</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> school </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;ecust&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 不失效</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>范围查询</strong>：联合索引中出现范围查询(<code>&gt;,&lt;</code>)，<strong>范围查询右侧的索引失效</strong></p><ul><li>最好使用<code>&gt;=</code>或者<code>&lt;=</code></li></ul><p>失效与否是看<strong>联合索引中列的先后顺序</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 联合索引: (name,age,school) 会失效</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 联合索引: (name,school,age) 不会失效</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;wjh&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> school </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;ecust&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="索引失效" tabindex="-1"><a class="header-anchor" href="#索引失效"><span>索引失效</span></a></h4><p><strong>导致索引失效的情况</strong></p><ul><li>在索引列上进行运算操作</li><li>字符串类型字段使用不加引号</li><li>头部模糊匹配（尾部模糊匹配<strong>不会</strong>导致索引失效）</li><li>使用<code>or</code>进行连接，一侧有索引，一侧无索引</li><li>MySQL评估<strong>走索引比全表扫描慢</strong></li></ul><h4 id="sql提示" tabindex="-1"><a class="header-anchor" href="#sql提示"><span>SQL提示</span></a></h4><p>当一个列被多个索引绑定时，可以使用SQL提示指定要使用哪个索引</p><p><strong>use index</strong>：使用指定索引，MySQL可能会拒绝使用指定索引</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- index_name: 索引名字</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(index_name)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ignore index</strong>：忽略指定索引</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- index_name: 索引名字</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ignore</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(index_name)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>force index</strong>：强制使用指定索引</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- index_name: 索引名字</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">force</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(index_name)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="索引使用" tabindex="-1"><a class="header-anchor" href="#索引使用"><span>索引使用</span></a></h4><p><strong>覆盖索引</strong>：当索引包含了查询所需要的所有字段，<strong>数据库引擎就可以直接从索引中获取数据而无需回表查询</strong></p><ul><li><code>using index condition</code>：查找使用了索引，但需要做<strong>回表查询</strong></li><li><code>using where;using index</code>：查找使用了索引，但是需要的数据在索引列中都可以找到，<strong>性能高</strong></li></ul><p><strong>前缀索引</strong>：取长字符串的<strong>一部分前缀</strong>建立索引，可以降低索引体积，节约空间</p><ul><li><strong>语法</strong></li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- idx_name: 索引名称</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- column: 列名</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- n: 取多少个字符</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name(column(n));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>前缀长度</strong>：可以根据索引的选择性来确定 <ul><li>选择性：不重复的索引值和数据表的记录总数的比值，选择性越高则查询效率越高</li><li>实际业务场景需要在<strong>前缀长度和选择性之间做平衡和取舍</strong></li></ul></li></ul><h4 id="索引设计原则" tabindex="-1"><a class="header-anchor" href="#索引设计原则"><span>索引设计原则</span></a></h4><ol><li>针对数据量较大（超过100万条），且查询比较频繁的表建立索引</li><li>对常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>选择区分度高的列作为索引，尽量建立<strong>唯一索引</strong></li><li>字符串类型的字段若长度较长，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，因为可避免回表查询</li><li>控制索引数量，索引太多会影响增删改的效率</li><li>如果列不存储NULL值，在创建表时使用<code>NOT NULL</code>进行约束，可以提升优化器查询的效率</li></ol><h3 id="sql性能分析" tabindex="-1"><a class="header-anchor" href="#sql性能分析"><span>SQL性能分析</span></a></h3><h4 id="查看执行频次" tabindex="-1"><a class="header-anchor" href="#查看执行频次"><span>查看执行频次</span></a></h4><p>使用下列语句得到SQL语句的执行频次</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 跟7个下划线</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">global</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> status</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> like</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Com_______&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="慢查询日志" tabindex="-1"><a class="header-anchor" href="#慢查询日志"><span>慢查询日志</span></a></h4><p>在<code>/etc/my.cnf</code>进行配置</p><div class="language-ini line-numbers-mode" data-highlighter="shiki" data-ext="ini" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-ini"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 开启慢查询日志开关</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">show_query_log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 设置慢查询的时间为2s，SQL语句执行时间超过2s就会被视为是慢查询</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">long_query_time</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="profile详情" tabindex="-1"><a class="header-anchor" href="#profile详情"><span>profile详情</span></a></h4><p>使用<code>show profiles</code>命令帮助了解每条SQL命令的耗时情况</p><p>使用以下命令可以查看当前MySQL是否支持<code>profile</code>操作</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @@have_profiling;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>默认<code>profiling</code>是关闭的，可以使用<code>set</code>命令打开</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> profiling</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>常见命令</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 查看每条SQL命令耗时情况</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show profilies;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 查看指定query_id的SQL语句各个阶段耗时情况</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">profile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> query query_id;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 查看指定query_id的SQL语句CPU使用情况</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">profile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cpu </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> query query_id;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="explain执行计划" tabindex="-1"><a class="header-anchor" href="#explain执行计划"><span>explain执行计划</span></a></h4><p>使用<code>explain/desc</code>可以获取MySQL如何执行<code>select</code>语句的信息</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 直接在select语句之前加上关键字explain/</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">desc</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>执行计划详情</strong></p><ul><li><code>id</code>：<code>select</code>查询的序列号，表示查询中执行<code>select</code>子句或者操作表的顺序 <ul><li>id相同，执行顺序从上到下</li><li>id不同，值越大越先执行</li></ul></li><li><code>select_type</code>：表示<code>select</code>的类型</li><li><code>type</code>：表示连接类型，性能<strong>由好到差</strong>分别为<code>NULL、system、const、eq_ref、ref、range、index、all</code></li><li><code>possible_key</code>：可能用到的索引</li><li><code>key</code>：实际用到的索引，如果为NULL则没有使用索引</li><li><code>key_len</code>：索引中使用的字节数，值为索引字段最大可能长度，保证精度的同时长度越短越好</li><li><code>rows</code>：MySQL认为必须要执行查询的行数，是估计值</li><li><code>filtered</code>：返回结果的行数占需读取函数的百分比，值<strong>越大越好</strong></li></ul><h3 id="sql优化" tabindex="-1"><a class="header-anchor" href="#sql优化"><span>SQL优化</span></a></h3><h5 id="insert优化" tabindex="-1"><a class="header-anchor" href="#insert优化"><span>insert优化</span></a></h5><ul><li><strong>执行批量插入</strong><ul><li>一次插入不要超过1000条</li></ul></li><li><strong>手动提交事务</strong></li><li><strong>主键顺序插入</strong></li></ul><p>如果一次性需要插入大批量数据，使用<code>load</code>指令进行插入</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 客户端连接服务端时，加上参数 </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--local-infile</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">mysql </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--local-infile -u root -p</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> global</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> local_infile</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 执行load指令将准备好的数据加载到表结构中</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- local_file: 本地文件路径</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- tb_name: 表名</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- ,: 每一个字段用逗号分隔</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- .: 每一行用&#39;.&#39;分隔</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">load</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> data</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> local</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> infile </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;local_file&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> into</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;tb_name&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> fields terminated </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">by</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;,&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lines terminated </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">by</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;\\n&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="主键优化" tabindex="-1"><a class="header-anchor" href="#主键优化"><span>主键优化</span></a></h5><p><strong>索引组织表</strong>：在InnoDB中，表数据是根据<strong>主键顺序</strong>组织存放的</p><p><strong>页分裂</strong></p><ul><li>主键乱序插入时会导致页分裂</li><li>开启新的数据页，找到第一个数据页百分之50的位置，将这个位置后面的数据放到新的数据页，并且把当前插入的数据也放到这个新的数据页，同时更替指针</li></ul><p><strong>页合并</strong></p><ul><li>当删除一行记录时，实际上记录并没有被物理删除，只是进行逻辑删除，它的空间<strong>允许被其它记录声明使用</strong></li><li>当页中删除的记录到达<code>MERGE_THERESHOLD</code>（默认为50%）时，InnoDB会寻找最近的页进行合并</li></ul><p><strong>优化原则</strong></p><ul><li>尽量降低主键长度</li><li>尽量选择顺序插入，选择使用<code>AUTO_INCREMENT</code>自增主键</li><li>不要选择UUID或者其它自然主键</li><li>避免对主键修改</li></ul><h5 id="order-by优化" tabindex="-1"><a class="header-anchor" href="#order-by优化"><span>order by优化</span></a></h5><p>有两种排序方法</p><ul><li><code>Using filesort</code>：通过表的索引或全表扫描获取符合条件的数据行，在<strong>排序缓冲区</strong><code>sort buffer</code>完成排序操作。所有<strong>不是通过索引直接返回排序结果</strong>的排序叫做<code>FileSort</code>排序 <ul><li>排序缓冲区大小默认为256K，不可避免排序的时候可以增大缓冲区大小</li></ul></li><li><code>Using index</code>：通过有序索引顺序扫描直接返回有序数据，不需要额外排序，效率高</li></ul><p>几种会<strong>出现<code>FileSort</code>的情况</strong></p><ul><li>查询时的条件违背最左前缀法则</li><li>没有对查询时指定的字段建立索引</li><li>索引默认是升序排列，查询时对多个字段分别进行<code>asc</code>、<code>desc</code>，此时可以创建对应的索引优化掉<code>FileSort</code></li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name (age </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">asc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> desc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>没有使用覆盖索引造成回表查询</li></ul><h5 id="group-by优化" tabindex="-1"><a class="header-anchor" href="#group-by优化"><span>group by优化</span></a></h5><ul><li><code>Using temporary</code>：使用临时表来分组，效率较低</li><li><code>Using index</code>：直接通过索引返回分组数据，效率较高</li></ul><p><strong>注意</strong></p><ul><li>分组操作可以建立索引来提高分组效率</li><li>分组操作时，索引使用满足最左前缀法则</li></ul><h5 id="limit优化" tabindex="-1"><a class="header-anchor" href="#limit优化"><span>limit优化</span></a></h5><p>在大数据量的情况下，<code>limit</code>分页越往后效率越低</p><p><strong>解决方法</strong>：覆盖索引+子查询</p><h5 id="count优化" tabindex="-1"><a class="header-anchor" href="#count优化"><span>count优化</span></a></h5><p>count的几种用法</p><ul><li><code>count(*)</code>：统计所有行数（包括NULL），InnoDB专门<strong>对此做了优化</strong></li><li><code>count(主键)</code>：有几个主键结果就是多少</li><li><code>count(字段)</code>：统计指定列<strong>非NULL</strong>值的行数</li><li><code>count(1)</code>：统计所有行数（包括NULL）</li></ul><p><strong>效率排序</strong>：<code>count(字段) &lt; count(主键) &lt; count(1) = count(*)</code></p><h5 id="update优化" tabindex="-1"><a class="header-anchor" href="#update优化"><span>update优化</span></a></h5><p>InnoDB的行锁是<strong>针对索引</strong>加的锁，如果索引失效或者匹配条件（where）的字段无索引，<strong>行锁会升级成表锁</strong>，降低并发性能</p><h3 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h3><p><code>autocommit</code>：是否为自动提交，1为自动提交事务，0为手动提交事务</p><p><strong>ACID</strong>：原子性、一致性、隔离性、持久性</p><p><strong>注意</strong></p><ul><li>修改数据但未提交，修改后的数据会出现在内存中</li><li>提交之后，修改的数据会被刷到磁盘</li></ul><h4 id="并发事务问题" tabindex="-1"><a class="header-anchor" href="#并发事务问题"><span>并发事务问题</span></a></h4><h5 id="脏读" tabindex="-1"><a class="header-anchor" href="#脏读"><span>脏读</span></a></h5><p>事务A读到了事务B<strong>尚未提交的修改</strong></p><h5 id="不可重复读" tabindex="-1"><a class="header-anchor" href="#不可重复读"><span>不可重复读</span></a></h5><p>一个事务先后读取到同一条记录，但<strong>两次读取的数据不同</strong>，通常是因为别的事务在中间提交了<code>UPDATE/DELETE</code></p><h5 id="幻读" tabindex="-1"><a class="header-anchor" href="#幻读"><span>幻读</span></a></h5><p>在同一事务中，多次执行相同的查询，但<strong>返回的结果集的行数发生变化</strong>，通常是因为别的事务在中间提交了<code>INSERT/DELETE</code></p><h4 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别"><span>事务隔离级别</span></a></h4><p>从上到下<strong>性能依次降低，数据安全性依次提高</strong></p><p><strong>RU</strong>（读未提交）</p><p><code>Read uncommitted</code>：无法解决并发事务问题</p><p><strong>RC</strong>（读已提交）</p><p><code>Read committed</code>：可以解决脏读</p><p><strong>RR</strong>（可重复读）</p><p><code>Repeatable Read</code>：可以解决不可重复读、脏读</p><p><strong>串行化</strong></p><p><code>Serializable</code>：可以解决脏读、不可重复读、幻读</p><p><strong>常用语法</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 查看事务隔离级别</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @@transaction_isolation;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 设置事务隔离级别</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [session|global]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> transaction</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> isolation</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> level</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [read uncommitted|read committed|repeatable read| serializable]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="锁" tabindex="-1"><a class="header-anchor" href="#锁"><span>锁</span></a></h3><p><strong>定义</strong>：计算机协调多个进程或线程并发访问某一资源的机制</p><h4 id="全局锁" tabindex="-1"><a class="header-anchor" href="#全局锁"><span>全局锁</span></a></h4><p>锁定<strong>数据库中的所有表</strong></p><ul><li><p>对数据库实例加锁，导致实例只处于<strong>可读状态</strong></p></li><li><p>常用在<strong>数据备份业务场景</strong>中，可以保证数据的一致性，保证数据完整</p></li></ul><p><strong>语法</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 给数据库加上全局锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">flush tables </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">with</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lock;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 进行数据备份</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- -h: 数据库所在的主机地址</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- uroot: 登录的用户名</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- -p: 密码</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- dbName: 要进行备份的数据库</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- fileName: 备份到磁盘的文件名称</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">mysqldump -h host -uroot -p pwd dbName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> fileName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">sql</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 解锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tables;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>存在的问题</strong></p><ul><li>在主库进行备份，需要加锁，但会导致<strong>业务停摆</strong></li><li>在从库进行备份，备份期间从库不能执行主库同步过来的二进制日志，导致<strong>主从延迟</strong></li></ul><p><strong>特点</strong></p><p>在InnoDB引擎下加上<code>--single-transaction</code>可以实现不加锁的数据一致性备份</p><ul><li>原理：基于MVCC机制的一致性快照</li><li>开启事务，创建一致性快照，实现数据备份</li><li>进行数据备份时，业务可正常执行，但备份的数据是事务开始时的一致性快照</li></ul><h4 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁"><span>表级锁</span></a></h4><p>每次操作锁住<strong>整张表</strong></p><p>主要分为<strong>三类</strong></p><ul><li>表锁</li><li>元数据锁</li><li>意向锁</li></ul><h5 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁"><span>表锁</span></a></h5><p><strong>保护整张表的所有数据</strong></p><p>可分为两类</p><ul><li><strong>表共享读锁</strong>（读锁/共享锁）：加锁的客户端只能读数据，不能写数据，其他客户端也如此</li><li><strong>表独占写锁</strong>（写锁/排他锁）：加锁的客户端可以读数据，也可以写数据，其他客户端不能读数据，也不能写数据</li></ul><p><strong>语法</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 加锁</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- tableName: 表名</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- read / write: 读/写锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lock tables tableName </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> / write</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 释放锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tables</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="元数据锁" tabindex="-1"><a class="header-anchor" href="#元数据锁"><span>元数据锁</span></a></h5><p>MDL：<code>Meta Data Lock</code></p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问表的时候会自动加上</p><p><strong>作用</strong>：<strong>维护表结构</strong>的数据一致性，在表上有活动事务时，不能对元数据进行写入操作</p><p><strong>特点</strong>：当对表进行增删改查时，加MDL读锁（共享锁）；当对表结构进行变更操作的时候，加MDL写锁（排他锁）</p><ul><li>MDL读锁 <ul><li><code>select</code>语句：加的锁类型是<code>SHARED_READ</code></li><li><code>insert、update、delete</code>语句：加的锁类型是<code>SHARED_WRITE</code></li><li><code>SHARED_READ</code>与<code>SHARED_WRITE</code>是兼容的，不会相互阻塞</li></ul></li><li>MDL写锁 <ul><li><code>alter</code>语句：加的锁类型是<code>EXCLUSIVE</code>，与其它锁类型互斥</li></ul></li></ul><h5 id="意向锁" tabindex="-1"><a class="header-anchor" href="#意向锁"><span>意向锁</span></a></h5><p><strong>作用</strong>：为了避免增删改查执行时<strong>加的行锁与表锁冲突</strong>，加入意向锁使得表锁不用检查每行数据是否加锁，减少表锁的检查</p><p><strong>类型</strong></p><ul><li><strong>意向共享锁</strong>（IS）：由<code>select</code>、<code>lock in share mode</code>添加 <ul><li>与表锁共享锁<strong>兼容</strong>，与表锁排他锁<strong>互斥</strong></li></ul></li><li><strong>意向排他锁</strong>（IX）：由<code>insert</code>、<code>update</code>、<code>delete</code>、<code>select ... for update</code>添加 <ul><li>与表锁共享锁和表锁排他锁<strong>都互斥</strong></li></ul></li></ul><h4 id="行级锁" tabindex="-1"><a class="header-anchor" href="#行级锁"><span>行级锁</span></a></h4><p>每次操作锁住<strong>对应的行数据</strong>，通过对索引上的索引项加锁实现，而不是对记录加锁</p><p>可分为以下三类：</p><ul><li>行锁</li><li>间隙锁</li><li>临键锁</li></ul><p>针对<code>select</code>获取锁</p><ul><li><code>lock in share mode</code>：获取共享锁</li><li><code>for update</code>：获取排他锁</li></ul><h5 id="行锁" tabindex="-1"><a class="header-anchor" href="#行锁"><span>行锁</span></a></h5><p><strong>锁定单个行记录</strong>，防止其它事务对此数据进行<code>update</code>和<code>delete</code>，在RC、RR隔离级别下支持</p><p>有两种类型：</p><ul><li>共享锁：用于读数据，其他事务可以对该行<strong>加共享锁，但不能加排他锁</strong></li><li>排他锁：用于写数据，其他事务<strong>不能对该行加共享锁和排他锁</strong></li></ul><p><strong>SQL与对应的锁类型</strong></p><table><thead><tr><th style="text-align:center;">SQL</th><th style="text-align:center;">锁类型</th></tr></thead><tbody><tr><td style="text-align:center;"><code>insert</code></td><td style="text-align:center;">排他锁</td></tr><tr><td style="text-align:center;"><code>update</code></td><td style="text-align:center;">排他锁</td></tr><tr><td style="text-align:center;"><code>delete</code></td><td style="text-align:center;">排他锁</td></tr><tr><td style="text-align:center;"><code>select</code></td><td style="text-align:center;"><strong>不加锁</strong></td></tr><tr><td style="text-align:center;"><code>select ... lock in share mode</code></td><td style="text-align:center;">共享锁</td></tr><tr><td style="text-align:center;"><code>select ... for update</code></td><td style="text-align:center;">排他锁</td></tr></tbody></table><p><strong>注意</strong></p><ul><li>针对唯一索引进行检索时，会被<strong>自动优化为行锁</strong></li><li>不通过索引条件检索数据，<strong>行锁会升级为表锁</strong></li></ul><h5 id="间隙锁" tabindex="-1"><a class="header-anchor" href="#间隙锁"><span>间隙锁</span></a></h5><p><strong>锁住索引记录间隙（不含该记录）</strong>，防止其他事务在这个间隙进行<code>insert</code>，产生<strong>幻读</strong>，在RR隔离级别下支持</p><p><strong>注意</strong></p><ul><li>索引（<strong>唯一索引</strong>）上的等值查询，给不存在的记录加锁，<strong>临键锁优化为间隙锁</strong></li><li>索引（<strong>普通索引</strong>）上的等值查询，向右遍历到最后一个不满足查询条件的值，对这段间隙加锁，此时<strong>临键锁退化为间隙锁</strong><ul><li>因为索引不唯一，可能在该值的前面和后面插入相同值的数据，导致幻读，因此要加间隙锁</li></ul></li><li>索引（<strong>唯一索引</strong>）上的范围查询，使用<strong>临键锁</strong>，锁住数据的同时还锁住<strong>查询范围内间隙</strong></li><li><strong>间隙锁可以共存</strong>，一个事务的间隙锁不会影响另一个事务在同一间隙上加间隙锁</li></ul><h5 id="临键锁" tabindex="-1"><a class="header-anchor" href="#临键锁"><span>临键锁</span></a></h5><p><strong>行锁和间隙锁的综合</strong>，锁住数据，并锁住数据前面的间隙，在RR隔离级别下支持</p><p>默认情况下，InnoDB使用<strong>临键锁</strong>进行搜索和扫描，<strong>防止幻读</strong></p>`,256)])])}const A=s(p,[["render",c]]),u=JSON.parse('{"path":"/golang/DB.html","title":"","lang":"zh-CN","frontmatter":{"description":"本页PDF DB的查漏补缺 MySQL体系结构 MySQL服务端 连接层：负责权限校验，连接处理等 服务层：负责SQL分析和优化，SQL接口等 引擎层：可插拔的存储引擎层，不同的存储引擎有不同的功能，索引是在这个层实现的 存储层：将数据存储在磁盘中，并完成与存储引擎的交互 image-20260117170137026image-20260117170...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://xbzhong.cn/screenshot/backend/image-20260117170137026.png\\",\\"https://xbzhong.cn/screenshot/backend/image-20260117171642309.png\\",\\"https://xbzhong.cn/screenshot/backend/image-20260117192823578.png\\",\\"https://xbzhong.cn/screenshot/backend/image-20260116134036265.png\\",\\"https://xbzhong.cn/screenshot/backend/image-20260116134013876.png\\",\\"https://xbzhong.cn/screenshot/backend/image-20260116134539535.png\\"],\\"dateModified\\":\\"2026-02-12T06:19:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xbZhong\\",\\"email\\":\\"2396768163@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://xbzhong.cn/golang/DB.html"}],["meta",{"property":"og:site_name","content":"阿b的博客"}],["meta",{"property":"og:description","content":"本页PDF DB的查漏补缺 MySQL体系结构 MySQL服务端 连接层：负责权限校验，连接处理等 服务层：负责SQL分析和优化，SQL接口等 引擎层：可插拔的存储引擎层，不同的存储引擎有不同的功能，索引是在这个层实现的 存储层：将数据存储在磁盘中，并完成与存储引擎的交互 image-20260117170137026image-20260117170..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xbzhong.cn/screenshot/backend/image-20260117170137026.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-12T06:19:30.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-12T06:19:30.000Z"}]]},"git":{"createdTime":1770877170000,"updatedTime":1770877170000,"contributors":[{"name":"BO","username":"BO","email":"2396768163@qq.com","commits":1,"url":"https://github.com/BO"}]},"readingTime":{"minutes":22.58,"words":6775},"filePathRelative":"golang/DB.md","excerpt":"<p><a href=\\"/pdfs/golang/DB.pdf\\">本页PDF</a></p>\\n<h2>DB的查漏补缺</h2>\\n<h3>MySQL体系结构</h3>\\n<p><strong>MySQL服务端</strong></p>\\n<ul>\\n<li><strong>连接层</strong>：负责权限校验，连接处理等</li>\\n<li><strong>服务层</strong>：负责SQL分析和优化，SQL接口等</li>\\n<li><strong>引擎层</strong>：可插拔的存储引擎层，不同的<strong>存储引擎</strong>有不同的功能，索引是在这个层实现的</li>\\n<li><strong>存储层</strong>：将数据存储在磁盘中，并完成与存储引擎的交互</li>\\n</ul>","autoDesc":true}');export{A as comp,u as data};
