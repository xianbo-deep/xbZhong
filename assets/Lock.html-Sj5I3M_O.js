import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,e as s,o as n}from"./app-CQf0aGF7.js";const l={};function t(r,i){return n(),o("div",null,[...i[0]||(i[0]=[s('<h2 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁"><span>悲观锁</span></a></h2><p>悲观锁认为自己在使用数据的时候<strong>一定会有别的线程来修改数据</strong>，因此在获取数据的时候会先加锁，确保数据不会被其他线程修改</p><ul><li><strong><code>synchronized</code>和<code>Lock</code>接口的实现类都是悲观锁</strong></li></ul><h2 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁"><span>乐观锁</span></a></h2><p>乐观锁认为自己在使用数据的时候<strong>不会有别的线程修改数据</strong>，所以不会添加锁</p><ul><li>如果这个数据没有被更新，当前线程会将自己修改的数据成功写入</li><li>如果数据已经被其它线程更新，根据不同的方式执行不同的操作</li></ul><p><strong>采用无锁编程实现，常用<code>CAS</code>算法</strong></p><p><code>java.util.concurrent</code>包中的原子类就是通过<code>CAS</code><strong>实现了乐观锁</strong></p><p><code>CAS</code>算法涉及到三个操作数：</p><ul><li>需要读写的内存值V，也就是<strong>数据库中的值</strong></li><li>进行比较的值A，<strong>初始时做查询得到的值</strong></li><li>要写入的新值B</li></ul><p><strong>基本思想：​​​​</strong></p><ul><li>比较内存值V和旧的期望值A是否相等，相等则把B的值写入内存</li><li>如果不相等则<strong>重复执行刚才的操作直到成功</strong></li></ul><p><strong>ABA问题：​​​​</strong>资源被从A改成B，又从B改成A，说明这个资源被修改过，但是之前的方法是检测不出来的</p><ul><li>解决思路：在变量前面追加上<strong>版本号或者时间戳</strong></li></ul><h2 id="公平锁" tabindex="-1"><a class="header-anchor" href="#公平锁"><span>公平锁</span></a></h2><p>公平锁是指多个线程<strong>按照申请锁的顺序来获得锁</strong>，线程直接进入队列中排队</p><ul><li>等待锁的线程不会饿死</li><li>整体吞吐效率较低</li></ul><p><strong>实现</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Lock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> l </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ReentrantLock</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="非公平锁" tabindex="-1"><a class="header-anchor" href="#非公平锁"><span>非公平锁</span></a></h2><p>非公平锁是指资源加锁后，新进来的线程会和队列中排队的线程进行竞争，<strong>竞争成功则拿到锁，失败则需到队列进行排队</strong></p><ul><li>等待锁的线程可能饿死</li><li>吞吐效率高</li></ul><p><strong>实现</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Lock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> l </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ReentrantLock</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="排他锁-写锁" tabindex="-1"><a class="header-anchor" href="#排他锁-写锁"><span>排他锁（写锁）</span></a></h2><p>排他锁指的是该锁一次只能被一个线程所持有</p><ul><li><code>synchronized</code>、<code>ReentrantReadWriteLock.WriteLock</code>和<code>Lock</code>的实现类都是<strong>排他锁</strong></li></ul><h2 id="共享锁-读锁" tabindex="-1"><a class="header-anchor" href="#共享锁-读锁"><span>共享锁（读锁）</span></a></h2><p>共享锁指的是该锁能被多个线程所持有</p><ul><li>获得共享锁的线程只能读数据，不能修改数据</li><li><code>ReentrantReadWriteLock.ReadLock</code>是共享锁</li></ul><h2 id="可重入锁-递归锁" tabindex="-1"><a class="header-anchor" href="#可重入锁-递归锁"><span>可重入锁（递归锁）</span></a></h2><p>可重入锁指的是在同一个线程在<strong>外层方法获得锁</strong>的时候，<strong>内层方法会自动获得锁</strong>，不会因为之前的锁没释放而造成阻塞</p><ul><li><code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁</li><li>一定程度上可以避免死锁</li></ul><h2 id="synchronize" tabindex="-1"><a class="header-anchor" href="#synchronize"><span>Synchronize</span></a></h2><ul><li><p>随着并发量的增加，锁的形态也会发生变化</p></li><li><p>锁越重，性能越差，但越安全</p></li></ul><h3 id="无锁" tabindex="-1"><a class="header-anchor" href="#无锁"><span>无锁</span></a></h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改资源，最终只有一个线程可以修改成功</p><ul><li><p>修改操作在循环内进行，线程会不断尝试修改共享资源，如果出现冲突会一直<strong>进行循环尝试</strong></p></li><li><p>CAS原理就是基于无锁的实现</p></li></ul><h3 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁"><span>偏向锁</span></a></h3><p>偏向锁是指一段同步代码一直被一个线程所访问，该线程会自动获取锁，<strong>可以看作是一个可重入锁</strong></p><ul><li>只有线程第一次获取锁的时候会进行一次CAS操作</li><li>轻量级锁的获取和释放依赖多次CAS原子指令</li><li>线程不会主动释放偏向锁，除非有别的<strong>线程来竞争偏向锁</strong><ul><li>偏向锁的撤销需要等待<strong>全局安全点</strong>（在这个时间点上没有字节码正在执行，此时不会执行任何代码） <ul><li>安全点：<strong>线程的执行状态时确定的</strong>，JVM可以安全地执行一些需要暂停所有线程的操作</li></ul></li><li>首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到<strong>无锁或轻量级锁</strong>的状态</li></ul></li></ul><p><strong>工作流程</strong>：</p><ul><li>当一个线程访问同步代码块并获取锁，JVM会检查<strong>对象头</strong>的<code>Mark Word</code><ul><li>如果此时无锁，JVM会通过<code>CAS</code>操作在<code>Mark Word</code>中的线程ID字段改成线程的ID</li><li>如果成功，该线程就<strong>拥有了该对象的锁</strong></li></ul></li><li>线程进入和退出的时候检测<code>Mark Word</code>是否存储着当前线程的ID</li></ul><h3 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁"><span>轻量级锁</span></a></h3><p>轻量级锁指的是当锁是偏向锁的时候，其它<strong>线程也在访问</strong>，偏向锁会升级成轻量级锁，其它线程会通过<strong>自旋的方式尝试获得锁（不阻塞）</strong></p><ul><li><p>每个线程加锁或释放锁都会使用CAS去操作</p></li><li><p>若当前只有一个等待线程，则该线程通过<strong>自旋进行等待</strong></p><ul><li>当<strong>自旋超过一定次数</strong>或者<strong>一个线程持有锁，一个在自旋等待，又有第三个线程来访时</strong>，轻量级锁会升级成重量级锁</li></ul></li><li><p>采用的<strong>自旋方式是自适应自旋</strong>，自旋这种获得锁的方式<strong>会占用CPU资源</strong></p><ul><li>收集锁的运行时信息（自旋成功率、锁持有时间等），动态调整自旋策略 <ul><li>成功率高：增加自旋次数，延长等待时间</li><li>失败率高：减少自旋次数，甚至直接阻塞</li></ul></li></ul></li></ul><p><strong>工作流程：​​​​</strong></p><ul><li>JVM会在当前线程的栈帧中建立一个名为<strong>锁记录（<code>Lock Record</code>）的空间</strong>，然后copy对象头中的<code>Mark Word</code>到锁记录中</li><li>JVM使用CAS操作尝试将对象的**<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针**，并将**<code>Lock Record</code>的<code>owner</code>指针指向对象的<code>Mark Word</code>**</li><li>如果更新操作成功，说明该线程拥有了该对象的锁</li><li>如果更新失败，JVM会先检查对象的<code>Mark Word</code>是否指向当前线程的栈帧 <ul><li>如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行</li><li>否则说明多个线程竞争锁</li></ul></li></ul><h3 id="重量级锁" tabindex="-1"><a class="header-anchor" href="#重量级锁"><span>重量级锁</span></a></h3><p>重量级锁是通过**互斥量（Mutex）**来实现的，一个线程获取到锁进入同步块，没释放锁之前，<strong>会阻塞其它未获得锁的线程</strong></p><ul><li>导致应用态切换到内核态</li><li>依赖于<code>C++</code>层面的<code>ObjectMonitor</code>对象，这个监视器最终会调用操作系统的<strong>互斥量来管理线程的挂起和唤醒</strong><ul><li>当线程无法获得重量级锁时，它会被<strong>挂起</strong>，需要从用户态陷入到内核态</li><li>锁被释放时，需要<strong>唤醒</strong>队列中等待的线程，也会导致线程从用户态陷入到内核态 <ul><li>状态切换开销大</li><li>被挂起的线程会发生线程上下文切换，<strong>保存当前线程的状态并加载被唤醒线程的状态</strong>，十分耗时</li></ul></li></ul></li></ul><p><strong>工作流程</strong></p><ul><li>当轻量级锁竞争加剧（自选超过一定次数），<strong>会升级为重量级锁，称为锁膨胀</strong></li><li><code>Mark Word</code>中指向的<strong>不再是栈帧中的锁记录</strong>，而是指向**<code>ObjectMonitor</code>**的指针</li><li>所有未抢到锁的线程都会进入<strong>阻塞状态</strong>，开销最大</li></ul><p><code>ObjectMonitor</code></p><ul><li>每一个对象可以作为一个锁，当一个线程试图执行一个由<code>synchronized</code>修饰的代码块或方法时，它<strong>要先获得这个对象对应的监视器锁</strong>（背后实现就是<code>ObjectMonitor</code>）</li><li>当锁升级为重量级锁，<code>Mark Word</code>中就会存储一个指向<code>ObjectMonitor</code>的指针，线程就可以通过对象找到对应的<code>ObjectMonitor</code>，进行<strong>加锁和解锁的操作</strong></li><li><strong>作用：​​​​</strong><ul><li>实现互斥锁</li><li>支持可重入锁</li><li>管理线程阻塞和唤醒</li></ul></li><li><strong>工作流程：​​​​</strong><ul><li>加锁 <ol><li><strong>检查锁状态</strong>：如果<code>_owner==null</code>，线程通过CAS抢锁，成功则称为<code>_owner</code></li><li>如果<code>_owner=当前线程</code>，此时锁为<strong>可重入锁</strong>，<code>_recursions++</code></li><li>让线程进行<strong>短暂自旋，尝试抢锁</strong>，自旋失败则进入<code>_EntryList</code>队列</li></ol></li><li>解锁 <ol><li><strong>减少重入次数</strong>：当<code>_recursions==0</code>则完全释放锁</li><li><strong>唤醒等待线程</strong>：从<code>_EntryList</code>唤醒一个<strong>线程竞争锁（非公平）</strong></li></ol></li><li>等待/唤醒 <ol><li>线程释放锁，进入<code>_WaitSet</code>队列</li><li>被<code>notify()</code>唤醒后，移入<code>_EntryList</code>重新竞争锁</li></ol></li></ul></li></ul>',55)])])}const d=e(l,[["render",t]]),p=JSON.parse('{"path":"/backend/Lock.html","title":"常见锁","lang":"zh-CN","frontmatter":{"title":"常见锁","description":"并发编程前置知识吧，就是对一些常见锁做了概念上的阐述","author":"xbZhong","isOriginal":true,"article":false,"category":"backend","timeline":true,"icon":"material-symbols:lock-outline","date":"2025-09-02T00:00:00.000Z","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"常见锁\\",\\"description\\":\\"并发编程前置知识吧，就是对一些常见锁做了概念上的阐述\\"}"],["meta",{"property":"og:url","content":"https://xbzhong.cn/backend/Lock.html"}],["meta",{"property":"og:site_name","content":"牢钟的博客"}],["meta",{"property":"og:title","content":"常见锁"}],["meta",{"property":"og:description","content":"并发编程前置知识吧，就是对一些常见锁做了概念上的阐述"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-11T10:07:48.000Z"}],["meta",{"property":"article:author","content":"xbZhong"}],["meta",{"property":"article:published_time","content":"2025-09-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-11T10:07:48.000Z"}]]},"git":{"createdTime":1760100316000,"updatedTime":1760177268000,"contributors":[{"name":"BO","username":"BO","email":"2396768163@qq.com","commits":3,"url":"https://github.com/BO"}]},"readingTime":{"minutes":7.09,"words":2128},"filePathRelative":"backend/Lock.md","excerpt":"<h2>悲观锁</h2>\\n<p>悲观锁认为自己在使用数据的时候<strong>一定会有别的线程来修改数据</strong>，因此在获取数据的时候会先加锁，确保数据不会被其他线程修改</p>\\n<ul>\\n<li><strong><code>synchronized</code>和<code>Lock</code>接口的实现类都是悲观锁</strong></li>\\n</ul>\\n<h2>乐观锁</h2>\\n<p>乐观锁认为自己在使用数据的时候<strong>不会有别的线程修改数据</strong>，所以不会添加锁</p>\\n<ul>\\n<li>如果这个数据没有被更新，当前线程会将自己修改的数据成功写入</li>\\n<li>如果数据已经被其它线程更新，根据不同的方式执行不同的操作</li>\\n</ul>"}');export{d as comp,p as data};
