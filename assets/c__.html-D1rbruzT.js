import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,e,o as i}from"./app-sdAdeonL.js";const a={};function n(o,t){return i(),r("div",null,[...t[0]||(t[0]=[e(`<h2 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象"><span>面向对象</span></a></h2><p><strong>封装，继承，多态</strong></p><h3 id="封装" tabindex="-1"><a class="header-anchor" href="#封装"><span>封装</span></a></h3><h4 id="访问权限" tabindex="-1"><a class="header-anchor" href="#访问权限"><span>访问权限</span></a></h4><ul><li>public : 类内可以访问，类外也可以访问</li><li>protected ： 类内可以访问，类外不可以访问，子类可以访问父类的保护内容</li><li>private ： 类内可以访问，类外不可以访问，子类不可以访问父类的私有内容<br><strong>struct默认访问权限是共有，class默认访问权限是私有</strong></li></ul><h3 id="对象的初始化和清理" tabindex="-1"><a class="header-anchor" href="#对象的初始化和清理"><span>对象的初始化和清理</span></a></h3><blockquote><ul><li>构造函数：进行初始化，对象创建时调用(编译器自动调用)<br> * 语法：类名()<br> * 无返回值也不写void<br> * 可有参数，可重载</li><li>可分为有参构造和无参构造，可以重载<br> * 拷贝构造，语法：(const person &amp;p)<br><strong>调用有参构造函数时加括号，括号里放相应的数据</strong></li><li>匿名对象(无类名)<br> * 语法：person()<br> * 当前行执行结束后系统会立即回收<br> * 可以赋值给对象</li></ul></blockquote><blockquote><ul><li>析构函数：进行清理，对象销毁前调用(编译器自动调用)<br> * 语法：~类名()<br> * 无返回值也不写void<br> * 不可有参数，不可发生重载<br> * 对象会自动释放</li></ul></blockquote><h4 id="构造函数调用规则" tabindex="-1"><a class="header-anchor" href="#构造函数调用规则"><span>构造函数调用规则</span></a></h4><ul><li>c++编译器至少给一个类添加3个函数 <ol><li>默认构造函数</li><li>默认析构函数</li><li>默认拷贝构造函数</li></ol></li><li>用户定义有参构造函数，c++不再提供默认无参构造，但会提供默认拷贝构造</li><li>用户定义拷贝构造函数，c++不再提供其它构造函数</li></ul><h4 id="深拷贝和浅拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝和浅拷贝"><span>深拷贝和浅拷贝</span></a></h4><ul><li>浅拷贝：简单的赋值拷贝操作 <ul><li>问题：堆区的内存重复释放</li></ul></li><li>深拷贝：在堆区重新申请空间，进行拷贝操作 <ul><li>用new，new的返回值是指针</li></ul></li></ul><h4 id="初始化列表" tabindex="-1"><a class="header-anchor" href="#初始化列表"><span>初始化列表</span></a></h4><p><strong>语法：构造函数():属性1(值1)，属性2(值2)，...{}</strong><br><strong>属性可以看成成员变量</strong></p><h4 id="静态成员" tabindex="-1"><a class="header-anchor" href="#静态成员"><span>静态成员</span></a></h4><ul><li>在前面加上static关键字</li><li>静态成员变量 <ul><li>所有对象共享一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li><li>访问方式 <ol><li>通过对象访问</li><li>通过类名访问 <strong>语法：类名::成员变量名</strong></li></ol></li></ul></li><li>静态成员函数 <ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量(因为实例对象还没有被创建，无法访问非静态成员变量)</li></ul></li></ul><h4 id="c-对象模型" tabindex="-1"><a class="header-anchor" href="#c-对象模型"><span>c++对象模型</span></a></h4><ul><li>编译器会对每个空对象分配一个字节空间，是为了区分空对象占内存的位置</li><li>静态成员变量((非)静态成员函数)不属于类对象上，也就不占用字节空间.<strong>也就是只有非静态成员变量属于类的对象</strong></li></ul><h4 id="this指针" tabindex="-1"><a class="header-anchor" href="#this指针"><span>this指针</span></a></h4><p><strong>this指针指向被调用的成员函数所属的对象</strong><br> 用途：</p><ul><li>形参和成员变量同名，可以用this指针区分</li><li>在类的非静态成员函数返回对象本身(return *this)<br><strong>要注意值传递和引用传递的区别</strong><br><strong>引用会使编译器只对一个值进行操作，值传递是创建一个副本并将要操作的数据拷贝到这个副本，对这个副本进行操作</strong></li><li>在成员函数后面加const，会使得this指针指向的值也无法修改</li><li>若想修改，则需要加变量前加mutable关键字(常对象只能调用常函数)</li></ul><h4 id="友元-friend" tabindex="-1"><a class="header-anchor" href="#友元-friend"><span>友元(friend)</span></a></h4><p><strong>目的就是让一个函数或者类，访问另一个类中的私有成员</strong></p><ol><li>全局函数做友元 <ul><li>将函数连同参数复制进类中，加上friend关键字</li></ul></li><li>类做友元 <ul><li>将类名放到要读取私有成员的类中，加上friend关键字</li></ul></li><li>成员函数做友元 <ul><li>将成员函数放到要读取私有成员的类中，前面加上类名</li></ul></li></ol><h4 id="运算符重载" tabindex="-1"><a class="header-anchor" href="#运算符重载"><span>运算符重载</span></a></h4><blockquote><p>语法：<strong>返回值类型(可以是类名) operator 重载的运算符(参数){函数体}；</strong></p></blockquote><p><strong>可以使用全局函数和成员函数来重载运算符</strong></p><h5 id="左移运算符重载" tabindex="-1"><a class="header-anchor" href="#左移运算符重载"><span>左移运算符重载</span></a></h5><ul><li><p>一般不使用成员函数重载左移运算符，无法实现cout在左边</p></li><li><p>而使用全局函数来重载<br> 语法：</p><pre><code>  ostream &amp;operator&lt;&lt;(ostream &amp;cout,person &amp;p)
  {
      cout &lt;&lt; p.m_A &lt;&lt; p.m_B;
      return cout; //返回cout可以使得输出p时输出别的内容
  }
</code></pre></li></ul><h5 id="重载-运算符" tabindex="-1"><a class="header-anchor" href="#重载-运算符"><span>重载++运算符</span></a></h5><ul><li>重载前置++运算符: 返回值类型 &amp;operator++() {};</li><li>重载后置++运算符: 返回值类型 &amp;operator++(int){};</li></ul><h3 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h3><p><strong>语法：class 子类：public 父类</strong></p>`,33)])])}const c=l(a,[["render",n]]),h=JSON.parse('{"path":"/ds/c__.html","title":"CPP常见知识","lang":"zh-CN","frontmatter":{"title":"CPP常见知识","author":"xbZhong","isOriginal":true,"article":false,"category":"ds","timeline":true,"icon":"hugeicons:cpp","description":"面向对象 封装，继承，多态 封装 访问权限 public : 类内可以访问，类外也可以访问 protected ： 类内可以访问，类外不可以访问，子类可以访问父类的保护内容 private ： 类内可以访问，类外不可以访问，子类不可以访问父类的私有内容 struct默认访问权限是共有，class默认访问权限是私有 对象的初始化和清理 构造函数：进行初始...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"CPP常见知识\\",\\"description\\":\\"面向对象 封装，继承，多态 封装 访问权限 public : 类内可以访问，类外也可以访问 protected ： 类内可以访问，类外不可以访问，子类可以访问父类的保护内容 private ： 类内可以访问，类外不可以访问，子类不可以访问父类的私有内容 struct默认访问权限是共有，class默认访问权限是私有 对象的初始化和清理 构造函数：进行初始...\\"}"],["meta",{"property":"og:url","content":"https://xbzhong.cn/ds/c__.html"}],["meta",{"property":"og:site_name","content":"阿b的博客"}],["meta",{"property":"og:title","content":"CPP常见知识"}],["meta",{"property":"og:description","content":"面向对象 封装，继承，多态 封装 访问权限 public : 类内可以访问，类外也可以访问 protected ： 类内可以访问，类外不可以访问，子类可以访问父类的保护内容 private ： 类内可以访问，类外不可以访问，子类不可以访问父类的私有内容 struct默认访问权限是共有，class默认访问权限是私有 对象的初始化和清理 构造函数：进行初始..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-10T12:45:16.000Z"}],["meta",{"property":"article:author","content":"xbZhong"}],["meta",{"property":"article:modified_time","content":"2025-10-10T12:45:16.000Z"}]]},"git":{"createdTime":1760100316000,"updatedTime":1760100316000,"contributors":[{"name":"BO","username":"BO","email":"2396768163@qq.com","commits":1,"url":"https://github.com/BO"}]},"readingTime":{"minutes":3.84,"words":1153},"filePathRelative":"ds/c++.md","excerpt":"<h2>面向对象</h2>\\n<p><strong>封装，继承，多态</strong></p>\\n<h3>封装</h3>\\n<h4>访问权限</h4>\\n<ul>\\n<li>public : 类内可以访问，类外也可以访问</li>\\n<li>protected ： 类内可以访问，类外不可以访问，子类可以访问父类的保护内容</li>\\n<li>private ： 类内可以访问，类外不可以访问，子类不可以访问父类的私有内容<br>\\n<strong>struct默认访问权限是共有，class默认访问权限是私有</strong></li>\\n</ul>\\n<h3>对象的初始化和清理</h3>\\n<blockquote>\\n<ul>\\n<li>构造函数：进行初始化，对象创建时调用(编译器自动调用)<br>\\n* 语法：类名()<br>\\n* 无返回值也不写void<br>\\n* 可有参数，可重载</li>\\n<li>可分为有参构造和无参构造，可以重载<br>\\n* 拷贝构造，语法：(const person &amp;p)<br>\\n<strong>调用有参构造函数时加括号，括号里放相应的数据</strong></li>\\n<li>匿名对象(无类名)<br>\\n* 语法：person()<br>\\n* 当前行执行结束后系统会立即回收<br>\\n* 可以赋值给对象</li>\\n</ul>\\n</blockquote>","autoDesc":true}');export{c as comp,h as data};
