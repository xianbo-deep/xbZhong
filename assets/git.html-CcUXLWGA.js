import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,e as r,o as e}from"./app-DGsg60wG.js";const l={};function n(o,t){return e(),i("div",null,[...t[0]||(t[0]=[r('<h2 id="git" tabindex="-1"><a class="header-anchor" href="#git"><span>Git</span></a></h2><p><mark><strong>分布式版本控制工具</strong></mark></p><h2 id="版本控制" tabindex="-1"><a class="header-anchor" href="#版本控制"><span>版本控制</span></a></h2><p><strong>版本控制是一种管理和跟踪文件更改的系统，主要用于协作开发中跟踪代码或文档的修改历史。它允许你随时<strong style="color:Red;">回溯到任何一个历史版本</strong>，并在多人合作时有效地处理多个修改。</strong></p><h3 id="分布式版本控制" tabindex="-1"><a class="header-anchor" href="#分布式版本控制"><span>分布式版本控制</span></a></h3><ul><li><strong>不依赖于中央服务器，可以在本地进行版本控制，<strong style="color:Red;">每个开发者都有项目的完整副本</strong></strong></li><li><strong>每个开发者都可以互相查看代码，只需要对别人的仓库进行同步</strong></li></ul><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程"><span>工作流程</span></a></h2><ul><li>工作区：写代码</li><li>暂存区：临时存储</li><li>本地库：历史版本</li><li>远程库：即代码托管中心，可以把本地库中的代码传到远程库</li><li>工作区和暂存区的代码可以删除，一旦把代码上传到本地库，代码就无法删除，只能覆盖</li></ul><h2 id="远程库-代码托管中心" tabindex="-1"><a class="header-anchor" href="#远程库-代码托管中心"><span>远程库(代码托管中心)</span></a></h2><ul><li>局域网：gitlab，非开源</li><li>互联网：github</li></ul><h2 id="git常用命令" tabindex="-1"><a class="header-anchor" href="#git常用命令"><span>git常用命令</span></a></h2><ul><li>git config --global <a href="http://user.name" target="_blank" rel="noopener noreferrer">user.name</a> 用户名：设置用户签名</li><li>git config --global user.email 邮箱：设置用户签名</li><li>git init：初始化本地库</li><li>git status：查看本地库状态</li><li>git add：后面跟文件名，将文件增加到暂存区</li><li>git rm --cached:后面跟文件名，从暂存区删除对应文件</li><li>git commit-m &quot;日志信息&quot; &quot;文件名&quot;:日志信息是版本信息</li><li>git reflog:查看版本号</li><li>git log:查看详细版本信息</li><li>vim 文件名:修改文件</li><li>cat 文件名:查看文件</li><li>git reset --hard 版本号:查看历史版本，版本穿梭</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git config --global <a href="http://user.name" target="_blank" rel="noopener noreferrer">user.name</a> 用户名</td><td>设置用户签名</td></tr><tr><td>git config --global user.email 邮箱</td><td>设置用户邮箱签名</td></tr><tr><td>git init</td><td>初始化本地库（需要在被管理的文件夹的路径下初始化）</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>后面跟文件名，将文件添加到暂存区</td></tr><tr><td>git rm --cached 文件名</td><td>后面跟文件名，在暂存区删除对应文件</td></tr><tr><td>git config list</td><td>查看配置文件中的所有配置项</td></tr><tr><td>git commit-m &quot;日志信息&quot; &quot;文件名&quot;</td><td>日志信息是版本信息，便于查看是哪个版本</td></tr><tr><td>git reflog</td><td>查看版本信息，可以看到对应的版本号</td></tr><tr><td>git reset -hard 版本号</td><td>版本穿梭</td></tr><tr><td>git fetch</td><td>用于从远程库拉取代码，可以在执行命令之后决定要不要合并到当前分支</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="gitlab" tabindex="-1"><a class="header-anchor" href="#gitlab"><span>Gitlab</span></a></h2><h3 id="git分支" tabindex="-1"><a class="header-anchor" href="#git分支"><span>Git分支</span></a></h3><ul><li>可以同时推进多个功能开发，提升效率，不影响用户的使用。一般来说只有master一个分支</li><li>git branch 分支名:创建分支</li><li>git branch -v：查看分支、</li><li>git checkout 分支名：切换分支</li><li>git merge 分支名：把指定的分支合并到当前分支上 <ul><li>冲突合并：同一个文件在不同分支都做了修改，需要手动合并，保留需要的代码，把不需要的代码和特殊符号删除并保存到暂存区</li></ul></li></ul><h4 id="跟踪远程分支" tabindex="-1"><a class="header-anchor" href="#跟踪远程分支"><span>跟踪远程分支</span></a></h4><p><strong>可以让<mark>本地分支跟踪远程分支</mark>，在进行push和pull时不用指定远程仓库</strong></p><h3 id="工作流介绍" tabindex="-1"><a class="header-anchor" href="#工作流介绍"><span>工作流介绍</span></a></h3><h4 id="功能开发工作流" tabindex="-1"><a class="header-anchor" href="#功能开发工作流"><span>功能开发工作流</span></a></h4><ul><li>在master分支上进行上线</li><li><mark>每个功能对应一个分支</mark>，在该分支上设计代码，开发功能</li><li>开发完功能后将代码合并到master分支进行上线</li></ul><h4 id="gitflow工作流" tabindex="-1"><a class="header-anchor" href="#gitflow工作流"><span>GitFlow工作流</span></a></h4><ul><li>在master分支上进行上线</li><li>在developer分支进行开发 <ul><li>要从master分支上先拉取到developer分支</li><li><mark>每个功能对应一个分支</mark>，在该分支上开发功能</li></ul></li><li>在测试分支上对开发的功能进行测试</li><li>在hotfix分支上进行修复代码，通常不需要改核心内容，只是<mark>对外部配置文件进行修改</mark></li></ul><h3 id="标记" tabindex="-1"><a class="header-anchor" href="#标记"><span>标记</span></a></h3><p><strong>对<mark>议题</mark>和<mark>合并请求</mark>进行标记，通常用于标记某个重要的代码版本</strong></p><h3 id="议题" tabindex="-1"><a class="header-anchor" href="#议题"><span>议题</span></a></h3><ul><li>用于跟踪和管理任务、错误、功能请求以及讨论的内容</li><li>议题提供了一个永久的记录，能够让团队回顾以前讨论的内容、决策、问题以及解决方案</li><li>可以在议题中创建分支，方便进行开发</li></ul><h3 id="冲突" tabindex="-1"><a class="header-anchor" href="#冲突"><span>冲突</span></a></h3><ul><li><mark><strong>往远程仓库进行推送时才会产生冲突</strong></mark></li><li>原因是因为<strong style="color:red;">远程库和本地库的版本不同</strong>，即远程库领先了多个commit</li></ul><h4 id="不同的人修改不同的文件" tabindex="-1"><a class="header-anchor" href="#不同的人修改不同的文件"><span>不同的人修改不同的文件</span></a></h4><ul><li>别人commit代码后，远程库版本更新，在你push时会产生冲突</li><li>可以直接进行merge合并，把最新的远程库版本拉取到本地，保证本地库和远程库的版本是一致的，然后再进行push</li></ul><h4 id="不同的人修改同文件的不同位置" tabindex="-1"><a class="header-anchor" href="#不同的人修改同文件的不同位置"><span>不同的人修改同文件的不同位置</span></a></h4><p><strong>直接merge即可</strong></p><ul><li>在不同位置修改文件后会使得远程库的版本领先于本地库</li><li>在push时会产生冲突，直接merge即可</li></ul><h4 id="不同的人修改同文件的相同位置" tabindex="-1"><a class="header-anchor" href="#不同的人修改同文件的相同位置"><span>不同的人修改同文件的相同位置</span></a></h4><ul><li>产生冲突的原因同上，但需要在push时进行手动合并</li><li>需要判断这个位置的代码要使用你自己的还是别人的，这时候，需要你进行手动合并，然后再进行push</li></ul><h4 id="不同的人修改同一文件的文件名" tabindex="-1"><a class="header-anchor" href="#不同的人修改同一文件的文件名"><span>不同的人修改同一文件的文件名</span></a></h4><ul><li>Git无法判断最终文件名的名字</li><li>需要在push前先进行pull或者fetch，<mark>手动</mark>决定使用什么文件名，然后再进行push</li></ul><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span><mark>注意事项</mark></span></a></h3><ol><li>远程库分支受保护时，不可以直接<mark>push</mark>，需要在本地新建一个和远程库不同名字的分支，然后push，<strong style="color:Red;">接着再gitlab上发送合并请求</strong></li><li><code>git pull -rebase</code>可以把你的本地提交“移到”远程更新之后，从而避免产生额外的合并提交。<mark>合并提交会将远程和本地的提交进行合并，然后在本地库进行提交</mark></li></ol>',40)])])}const h=a(l,[["render",n]]),g=JSON.parse('{"path":"/coding/git.html","title":"Git","lang":"zh-CN","frontmatter":{"title":"Git","author":"xbZhong","isOriginal":true,"article":true,"category":"code","timeline":true,"icon":"material-icon-theme:git","description":"Git 分布式版本控制工具 版本控制 版本控制是一种管理和跟踪文件更改的系统，主要用于协作开发中跟踪代码或文档的修改历史。它允许你随时回溯到任何一个历史版本，并在多人合作时有效地处理多个修改。 分布式版本控制 不依赖于中央服务器，可以在本地进行版本控制，每个开发者都有项目的完整副本 每个开发者都可以互相查看代码，只需要对别人的仓库进行同步 工作流程 工...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Git\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-10T12:45:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xbZhong\\"}]}"],["meta",{"property":"og:url","content":"https://xbzhong.cn/coding/git.html"}],["meta",{"property":"og:site_name","content":"牢钟的博客"}],["meta",{"property":"og:title","content":"Git"}],["meta",{"property":"og:description","content":"Git 分布式版本控制工具 版本控制 版本控制是一种管理和跟踪文件更改的系统，主要用于协作开发中跟踪代码或文档的修改历史。它允许你随时回溯到任何一个历史版本，并在多人合作时有效地处理多个修改。 分布式版本控制 不依赖于中央服务器，可以在本地进行版本控制，每个开发者都有项目的完整副本 每个开发者都可以互相查看代码，只需要对别人的仓库进行同步 工作流程 工..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-10T12:45:16.000Z"}],["meta",{"property":"article:author","content":"xbZhong"}],["meta",{"property":"article:modified_time","content":"2025-10-10T12:45:16.000Z"}]]},"git":{"createdTime":1760100316000,"updatedTime":1760100316000,"contributors":[{"name":"BO","username":"BO","email":"2396768163@qq.com","commits":1,"url":"https://github.com/BO"}]},"readingTime":{"minutes":5.11,"words":1533},"filePathRelative":"coding/git.md","excerpt":"<h2>Git</h2>\\n<p><mark><strong>分布式版本控制工具</strong></mark></p>\\n<h2>版本控制</h2>\\n<p><strong>版本控制是一种管理和跟踪文件更改的系统，主要用于协作开发中跟踪代码或文档的修改历史。它允许你随时<strong style=\\"color :Red\\">回溯到任何一个历史版本</strong>，并在多人合作时有效地处理多个修改。</strong></p>\\n<h3>分布式版本控制</h3>\\n<ul>\\n<li><strong>不依赖于中央服务器，可以在本地进行版本控制，<strong style=\\"color:Red\\">每个开发者都有项目的完整副本</strong></strong></li>\\n<li><strong>每个开发者都可以互相查看代码，只需要对别人的仓库进行同步</strong></li>\\n</ul>","autoDesc":true}');export{h as comp,g as data};
