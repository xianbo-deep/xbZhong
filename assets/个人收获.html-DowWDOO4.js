import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,e as r,o as s}from"./app-BOct2JLK.js";const g={};function e(i,t){return s(),o("div",null,[...t[0]||(t[0]=[r('<h2 id="线程、进程、协程、事件循环" tabindex="-1"><a class="header-anchor" href="#线程、进程、协程、事件循环"><span>线程、进程、协程、事件循环</span></a></h2><p><strong>进程</strong>（资源分配基本单位）</p><ul><li>进程可以看作是一个程序，比如小红书、王者荣耀这些**，进程有自己的独立堆栈空间**，进程间<strong>内存不共享</strong>，如果需要则需要<strong>进程通信</strong></li><li>进程<strong>创立/销毁都需要分配/释放资源</strong>，进程之间具有<strong>隔离性</strong></li></ul><p><strong>线程</strong>（调度执行基本单位）</p><ul><li>熟悉CPU可以从CPU核心入手，一个核心可以处理一个线程，<strong>多核心就可以执行多线程任务</strong><ul><li>线程<strong>并非越多越好</strong>，因为线程本质上是会<strong>抢占CPU资源执行任务的</strong>，表面上我们看起来是并行执行任务，实际上是<strong>CPU在瞬间不断切换去处理各个线程导致的</strong></li></ul></li><li>线程共享进程资源，这样会导致<strong>资源竞争问题</strong>，多个线程<strong>访问同一资源，管理不当会导致线程崩溃</strong>，常见方法有加锁（易导致死锁）</li><li><strong>一个进程中有多个线程</strong>，线程比进程更加轻量，<strong>线程是抢占式的</strong></li></ul><p><strong>协程</strong></p><ul><li><strong>比线程更加轻量，是由程序调度的</strong>，协程是<strong>协作式</strong>的 <ul><li>比如python，使用<code>await</code>的时候<strong>协程会让出CPU给其它协程执行任务</strong>，等到<strong>I/O（耗时操作，如文件读写等）操作结束后再执行自己的任务</strong></li><li>go、cpp都有自己的协程接口，这就是为什么大厂做后端用go比较多</li></ul></li><li><strong>多个协程在一个线程内交替执行</strong>，一个线程同一时刻<strong>只有一个协程进行</strong></li></ul><p><strong>事件循环</strong></p><ul><li>在js中较常见</li><li><strong>先</strong>处理同步任务，<strong>再</strong>处理异步任务 <ul><li>异步任务会有回调函数，异步任务执行完后会把<strong>回调函数放到任务队列里</strong></li><li>引擎执行完同步任务就会去<strong>任务队列取回调函数，执行异步任务</strong></li></ul></li><li>微任务和宏任务都是<strong>异步任务</strong><ul><li>微任务等级<strong>高</strong>，宏任务等级<strong>低</strong></li><li>引擎做完同步任务会执行完<strong>微任务队列的全部回调函数</strong></li><li>然后<strong>每执行一次宏任务队列的回调函数</strong>就再回到微任务队列看有没有<strong>新进来的微任务</strong></li></ul></li></ul>',9)])])}const p=n(g,[["render",e]]),c=JSON.parse('{"path":"/coding/%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%8E%B7.html","title":"实习的收获","lang":"zh-CN","frontmatter":{"title":"实习的收获","author":"xbZhong","isOriginal":true,"article":true,"category":"code","timeline":true,"icon":"fluent:reward-12-filled","description":"线程、进程、协程、事件循环 进程（资源分配基本单位） 进程可以看作是一个程序，比如小红书、王者荣耀这些**，进程有自己的独立堆栈空间**，进程间内存不共享，如果需要则需要进程通信 进程创立/销毁都需要分配/释放资源，进程之间具有隔离性 线程（调度执行基本单位） 熟悉CPU可以从CPU核心入手，一个核心可以处理一个线程，多核心就可以执行多线程任务 线程并...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"实习的收获\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-10T12:45:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xbZhong\\"}]}"],["meta",{"property":"og:url","content":"https://xbzhong.cn/coding/%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%8E%B7.html"}],["meta",{"property":"og:site_name","content":"牢钟的博客"}],["meta",{"property":"og:title","content":"实习的收获"}],["meta",{"property":"og:description","content":"线程、进程、协程、事件循环 进程（资源分配基本单位） 进程可以看作是一个程序，比如小红书、王者荣耀这些**，进程有自己的独立堆栈空间**，进程间内存不共享，如果需要则需要进程通信 进程创立/销毁都需要分配/释放资源，进程之间具有隔离性 线程（调度执行基本单位） 熟悉CPU可以从CPU核心入手，一个核心可以处理一个线程，多核心就可以执行多线程任务 线程并..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-10T12:45:16.000Z"}],["meta",{"property":"article:author","content":"xbZhong"}],["meta",{"property":"article:modified_time","content":"2025-10-10T12:45:16.000Z"}]]},"git":{"createdTime":1760100316000,"updatedTime":1760100316000,"contributors":[{"name":"BO","username":"BO","email":"2396768163@qq.com","commits":1,"url":"https://github.com/BO"}]},"readingTime":{"minutes":2.03,"words":610},"filePathRelative":"coding/个人收获.md","excerpt":"<h2>线程、进程、协程、事件循环</h2>\\n<p><strong>进程</strong>（资源分配基本单位）</p>\\n<ul>\\n<li>进程可以看作是一个程序，比如小红书、王者荣耀这些**，进程有自己的独立堆栈空间**，进程间<strong>内存不共享</strong>，如果需要则需要<strong>进程通信</strong></li>\\n<li>进程<strong>创立/销毁都需要分配/释放资源</strong>，进程之间具有<strong>隔离性</strong></li>\\n</ul>\\n<p><strong>线程</strong>（调度执行基本单位）</p>\\n<ul>\\n<li>熟悉CPU可以从CPU核心入手，一个核心可以处理一个线程，<strong>多核心就可以执行多线程任务</strong>\\n<ul>\\n<li>线程<strong>并非越多越好</strong>，因为线程本质上是会<strong>抢占CPU资源执行任务的</strong>，表面上我们看起来是并行执行任务，实际上是<strong>CPU在瞬间不断切换去处理各个线程导致的</strong></li>\\n</ul>\\n</li>\\n<li>线程共享进程资源，这样会导致<strong>资源竞争问题</strong>，多个线程<strong>访问同一资源，管理不当会导致线程崩溃</strong>，常见方法有加锁（易导致死锁）</li>\\n<li><strong>一个进程中有多个线程</strong>，线程比进程更加轻量，<strong>线程是抢占式的</strong></li>\\n</ul>","autoDesc":true}');export{p as comp,c as data};
