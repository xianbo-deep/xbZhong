---
title: 计网常见协议
author: xbZhong
isOriginal: true
article: true
category: backend
timeline: true
icon: streamline:network-solid
date: 2025-10-13
---
## 计网常见知识

### TCP/IP模型

**OSI和TCP/IP**

![image-20251013214454674](/screenshot/backend/image-20251013214454674.png)

如上图所示：

- 我们使用的`HTTPS`、`FTP`以及`HTTP`都属于**应用层**
- `TCP`、`UDP`都属于**传输层**
- `IP`则属于**网络层**

### Socket

**套接字**，就是ip地址+端口号

### TCP

**核心：三握四挥**

**TCP首部会用掉20个字节**

![image-20251013121751180](/screenshot/backend/image-20251013121751180.png)

**TCP报文里有SYN、ACK和FIN标识**

- 设置为1就是开启这些标识
- 设置为0就是关闭这些标识

#### 三次握手

**流程**

- 客户端发送SYN报文，并设置好序号
- 服务端发送SYN+ACK报文，设置序号，将确认号的值设置为客户端SYN报文的序号+1
- 客户端发送ACK报文，序号用服务端报文的确认号，确认号用服务端报文的序号+1

![image-20251013130002349](/screenshot/backend/image-20251013130002349.png)

#### 四次挥手

**流程**

- 主动断开方（可以是客户端，也可以是服务端）发送一个FIN和ACK报文，并设置好**序号和确认号**
- 被动断开方发送一个ACK报文，报文的序号为断开请求的确认号，**报文的确认号为断开请求的序号+1**
- 被动断开方还可以进行数据的发送，剩余数据发送完后，被动断开方会向主动断开方发送一个FIN+ACK结束响应报文
- 主动断开方在收到FIN+ACK断开响应报文后，还需要进行最后的确认，向被动断开方发送一个ACK确认报文，**序号为被动断开方的确认号，确认号为被动断开方的序号+1**

![image-20251013124408713](/screenshot/backend/image-20251013124408713.png)

**为什么要进行四次挥手？**

因为服务端可能还有数据需要发送

### UDP

**无连接、不可靠**的传输协议，常用在**端口寻址、实施在线游戏、实时音视频传输等**

**特点**

- **无连接**：通信前不需要建立连接，直接发送数据包即可
- **不可靠交付**：不提供确认、重传等机制
- **无拥塞控制**：不管网络状况多差，UDP都会以恒定的速率发送数据
- **支持广播**

**UDP首部只用掉8个字节**

![image-20251013121843576](/screenshot/backend/image-20251013121843576.png)

### IPV4和子网掩码

#### **IPV4**

`ipv4`是由**4组8位二进制组成的**，组之间用`.`隔开

`ip`地址 = 网络号 + 主机号

- **网络号**：同一个物理网络的所有设备，**网络号是相同的**
  - **路由寻址**：路由器只关心**目标IP地址的网络号**，从而实现数据包的转发
- **主机号**：IP地址中在特定网络内用于**标识唯一设备**的一部分
  - **最终交付**：数据包**到达目标网络**后，路由器会查看**目标IP的主机号**，从而将数据包准确地发送给正确的设备

**ip地址类型**

- A类：网络数为**128**，主机数为**16777216**
- B类：网络数为**16384**，主机数为**65536**
- C类：网络数为**2097152**，主机数为**256**

![image-20251013112742698](/screenshot/backend/image-20251013112742698.png)

**注意**

- **网络地址**的**主机位**全部为0，会占用1个ip，是整个网络的唯一标识
- **广播地址**的**主机位**全部位1，会占用1个ip，向网络中所有设备发送广播
- 因此，C类网络只能分配`256-2=254`个ip地址

#### **子网掩码**

**一个32位二进制数，为了划分网路号和主机号而产生的**

- **相同的网络号**会用**子网掩码的1**进行锁定
- 主机号**为0的二进制位**也会用**子网掩码的1**来进行锁定

也就是说，在子网掩码中

- **1对应的位是网络位**：标识一个子网。同一个子网内的所有IP地址，其网络位必须完全相同
- **0对应的位是主机位**：标识子网内的具体设备。主机位在子网内可变，且必须唯一

![image-20251013113529447](/screenshot/backend/image-20251013113529447.png)

#### **CIDR表示方法**

看子网掩码中有多少个1，在IP地址后加`/1的个数`即可

### IPV6

`ipv6`地址是由**128位二进制数**组成，通常以**十六进制**形式表示，分为**8组**，每组**16位二进制数（4个十六进制数字）**用**冒号**分隔

#### **地址压缩**

- **零压缩**：连续的零组可以用双冒号（`::`）表示，但在一个地址中只能使用一次
- **前导零压缩**：每组中的前导零可以省略，例如0001可以表示为1

#### **地址的组成部分**

**前缀**：前缀用于标识网络部分，类似于IPv4中的网络地址，前缀长度通常以斜杠后跟数字的形式表示

**接口标识符**：用于标识网络中的具体接口，通常为后64位

![image-20251013121120752](/screenshot/backend/image-20251013121120752.png)

#### 地址类型



![image-20251013121537369](/screenshot/backend/image-20251013121537369.png)

### NAT

**网络地址转换**

![image-20251013222829174](/screenshot/backend/image-20251013222829174.png)

**原理：**

- 内网访问外网通过出口路由时，源地址会转换成特定公有地址，并且将两个ip映射关系加到NAT映射表上
- 在外网向内网通信时，目的地址还是特定公有地址，但是到达出口路由器后，查看NAT映射表，从而转换为私有地址

**问题：**

- **破坏端到端通信**：两个都在NAT后的设备难以直接建立P2P连接
- **服务暴露困难**：外部网络无法直接主动访问NAT后的内部服务

#### 虚拟机网络

**NAT**

**图解**

![image-20251013221831854](/screenshot/backend/image-20251013221831854.png)

- 虚拟机之间无法互相访问
- 宿主机、局域网设备无法访问虚拟机
- 虚拟机可以通过宿主机访问互联网

**NAT网络**

**图解**

![image-20251013222040076](/screenshot/backend/image-20251013222040076.png)

- 在虚拟机前加了一台虚拟的交换机
- 加上了网关和DHCP服务

**桥接**

**图解**

![image-20251013222333237](/screenshot/backend/image-20251013222333237.png)

- 虚拟机和宿主机同级，在同一个网络里
- 宿主机和虚拟机在**同一个DHCP服务**获取私有IP地址，因此虚拟机会**消耗**宿主机所在局域网的IP地址

### DHCP

**使用UDP**

### VPN

**VPN的三个职责**

- 保密
- 认证
- 完整

![image-20251013203754926](/screenshot/backend/image-20251013203754926.png)

**全隧道模式**

**半隧道模式**

### DNS

**DNS默认使用UDP协议**

- 不出现**分片**情况下，UDP协议最大有效载荷是**512字节**以内
- 根服务器地址需要塞进一个**UDP包里**，最多只能放下**13组**记录

#### **域名结构树**

- 顶层的根`.`是由一群服务器组成的，**这群服务器只用了13个域名**

![image-20251013200644701](/screenshot/backend/image-20251013200644701.png)

#### **域名服务器类型**

![image-20251013201120277](/screenshot/backend/image-20251013201120277.png)

#### **DNS解析过程**

1. **浏览器缓存**：首先在浏览器检查是否有该域名对应的IP
2. **操作系统缓存**：如果没有，浏览器会调用操作系统（如通过 `gethostbyname`系统调用），检查本地的Hosts文件和操作系统DNS缓存
3. **本地DNS解析器**：如果本地没有，请求会发送到配置的**本地DNS服务器**
4. **根域名服务器**：若本地DNS解析器没有缓存，会向**根域名服务器**发起查询，**根域名服务器**只会返回负责你输入的域名的TLD（如`.com`、`.cn`）的**顶级域服务器地址**
5. **顶级域名服务器（TLD）**：本地DNS服务器再向TLD服务器查询，得到**权威域名服务器的**地址
6. **权威域名服务器**：最后，本地DNS服务器向权威域名服务器查询你输入的域名的IP
7. **返回并缓存**：本地DNS服务器将IP地址返回给操作系统，并缓存该记录。操作系统再返回给浏览器，并缓存

![image-20251013201551042](/screenshot/backend/image-20251013201551042.png)

#### 常见DNS记录类型

- **`A`记录**：将域名指向一个**IPv4**地址
- **`AAAA`记录**：将域名指向一个**IPv6**地址
- **`CNAME`记录**： 域名别名，将一个域名指向另一个域名
- **`MX`记录**： 邮件交换记录，指定负责接收邮件的服务器

### SSH

一种**加密的通信方式**，在SSH握手过程**使用非对称加密获得对称密钥**

#### 连接流程

- 进行TCP连接
- 进行SSH握手
- 客户端和服务端协商**SSH协议版本**
- 进行**密钥交换初始化**，协商应该使用什么**算法**
- 客户端生成**临时私钥**和**临时公钥**，将**临时公钥**发送给服务端
- 服务端生成**临时私钥**和**临时公钥**，将**客户端的临时公钥**和自己的**临时私钥**和**临时公钥**生成**共享安全密钥**
- 服务端将自己的**临时公钥**发送给客户端，客户端将**服务端的临时公钥**和自己的**临时私钥**和**临时公钥**生成**共享安全密钥**
- 服务端生成一对`host`公钥和`host`私钥，生成**交换哈希值**，并使用`host`私钥对交换哈希值进行加密，生成交换哈希值的**数字签名**，将**数字签名和`host`公钥**发送给客户端
- 客户端拿到服务端的`host`公钥对**数字签名**进行解密，并生成自己的**交换哈希值（客户端和服务端算出来的交换哈希值是一样的）**，比较二者是否一样

![image-20251013220614655](/screenshot/backend/image-20251013220614655.png)

#### 交换哈希值

**构成：**

- 客户端和服务端的**版本号字符串**
- 客户端和服务端密钥交换初始化负载（**算法名称的字符串**）
- 服务端的`host`公钥
- 客户端临时公钥和服务端临时公钥
- 共享安全密钥

#### 使用SSH证书

在客户端使用`ssh-keygen`命令生成密钥对，**私钥放在本地，使用`ssh-copy-id`将公钥发送给服务器**，可以实现免密登录，**提高登录安全性**

### HTTP

### HTTPS

**核心**：通过**非对称加密**安全的交换一个**对称加密的会话密钥**

默认端口是**443**

是对`Http`的升级，后面的`S`指的是`SSL/TLS`

- `Https` = `Http` + `SSL/TLS`

- `SSL/TLS`是一种加密安全协议，可以对发起http请求的请求和响应进行加密

- `SSL`是`TLS`的前身，现在很多浏览器都支持`TLS`

**对称加密**

**加密和解密用的是同一个密钥**

- 发送方用密钥和加密算法**对明文进行加密**
- 接收方用密钥和加密算法**对密文进行还原**

分发密钥时就会遇到**挑战**，通过网络传输的话**密钥容易被黑客截取**，黑客可以很轻松对密文进行还原

**非对称加密**

**客户端和服务端各使用一把公钥和一把私钥，公钥可进行传递，用于加密，私钥不可泄漏，用于解密**

- 发送方在网络上获取公钥，用自己的**私钥**和公钥对信息进行加密
- 接收方同样用**私钥**和公钥对信息进行解密
- 黑客无法知道**私钥**是什么，也就无法解密信息

![image-20251012193353851](/screenshot/backend/image-20251012193353851.png)

**SSL证书**

将网站的**身份信息与一个公钥**进行绑定，并由权威的**证书颁发机构（CA）**进行数字签名，证明其真实性



**TLS1.2握手流程（在这之前，服务端和客户端会进行TCP连接）**

1. 客户端发送`Client Hello`，TLS版本，加密套件和**第1随机数**（`Client Random`）给服务端
   - 第1随机数为一个由**客户端**生成的随机字符串
   - 客户端发送**它支持的加密套件列表**供服务端选择
2. 服务端发送`Server Hello`，TLS版本，加密套件和**第2随机数**（`Server Random`）给客户端
   - 第2随机数为一个由**服务端**生成的随机字符串
   - 此时返回给客户端服务端所选择的**加密套件**
3. 服务端发送**证书**给客户端
   - 证书包含了服务器的**公钥、域名、颁发机构、有效期**等信息
4. 服务端进行`Server Key Exchange`，发送自己的**临时公钥**
5. 服务端发送`Server Hello Done`，告诉客户端**信息发送完毕**
6. 客户端**验证证书**，如果证书不通过，连接中止
7. 客户端生成一个**预主密钥**，使用**服务端提供的公钥**进行加密，然后发送给**服务端**
8. 服务端利用自己的**私钥解密**得到**预主密钥**
   - 客户端和服务端按照**约定好的算法对这三个随机数生成相同的会话密钥**
9. 客户端告诉服务端**切换密码规范**，使用刚刚生成的**会话密钥**对会话内容进行加密
10. 客户端发送`Client Finished`完成消息
11. 服务端发送`Finished`消息

**握手总结**

- **预主密钥**是客户端生成的第3个随机数
- 后续的信息传输使用**会话密钥**

![image-20251012195424252](/screenshot/backend/image-20251012195424252.png)